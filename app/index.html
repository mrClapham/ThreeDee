<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script src="components/threejs/build/three.min.js"></script>
    <script src="js/vendor/three/loaders/ColladaLoader.js"></script>
    <script src="js/vendor/three/controls/OrbitControls.js"></script>
    <script src="components/gsap/src/minified/TweenLite.min.js"></script>
    <style type="text/css">
        #monkeyHolder{
            width:90%;
            height: 90%;
            background-color: #ccffcc;
        }
    </style>
</head>
<body onload="onLoaded()">
<div id="monkeyHolder">Monkey</div>
</body>
</html>
        <script type="text/javascript">
            var _scene, _camera, _renderer, _light, _lightAmbient;

            var _loadTraget = null;

            // Mouse and interaction

            var _mouse              =       new THREE.Vector2()
            var _projector          =       new THREE.Projector();
            var _raycaster          =       new THREE.Raycaster();
            var _bufferGeometry     =       new THREE.BufferGeometry();

            _bufferGeometry.addAttribute( 'position', new Float32Array( 4 * 3 ), 3 );
            var _lineMaterial = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2, transparent: false } );

            var _line = new THREE.Line( _bufferGeometry, _lineMaterial );

            //Control vars
            var _controls;
            // Camera vars
            var _fov      =  45;               //— Camera frustum vertical field of view.
            var _aspect   =  null;             //— Camera frustum aspect ratio.
            var _near     =  0.1;              //— Camera frustum near plane.
            var _far      =  20000;            //— Camera frustum far plane.

            //Environment
            var _backgroundColour = 0x454545;

            // Model
//            var _model = "models/monkey1.js",
            var _model = "models/LeePerrySmith.js",
                _lambertColour = 0x00ffff,
                _lambertArr = [0x00ccff,0x00ffcc,0x066fff,0x00ff33, 0x00ccff,0x00ffcc,0x066fff,0x00ff33,0x00ccff,0x00ffcc,0x066fff,0x00ff33,];

            // Store for the monkeys I created
            var _monkeys = []

            //
            var _clock = new THREE.Clock;

            /*
              COLLADA
            */

            var dae = null;



//
            function onLoaded(){
                _init();
            }
//
//            function loadCollada(){
//
//                var loader = new THREE.ColladaLoader();
//                loader.options.convertUpAxis = true;
//                loader.load( 'models/collada/monster/monster.dae', function ( collada ) {
//
//                    dae = collada.scene;
//                    skin = collada.skins[ 0 ];
//
//                    dae.scale.x = dae.scale.y = dae.scale.z = 0.002;
//                    dae.position.x = -1;
//                    dae.updateMatrix();
//
//                } );
//            }


            function _init(){
                // This is where I'm going to add the monkey
                _loadTraget = document.getElementById('monkeyHolder');

                //Scene
                _scene = new THREE.Scene();
                var WIDTH = window.innerWidth,
                    HEIGHT = window.innerHeight;
            /// For the hit test
                _scene.add( _line );


                //Renderer
                _renderer = new THREE.WebGLRenderer({antialias:true});
                _renderer.setSize(WIDTH, HEIGHT);
                _aspect = WIDTH / HEIGHT
                _loadTraget.appendChild(_renderer.domElement);

                // Create a camera, zoom it out from the model a bit, and add it to the scene.
                _camera = new THREE.PerspectiveCamera(_fov, _aspect, _near, _far);
                _camera.position.set(-50,6,0);
                _scene.add(_camera);

                // Create an event listener that resizes the renderer with the browser window.
                window.addEventListener('resize', function() {
                    var WIDTH = window.innerWidth,
                        HEIGHT = window.innerHeight;
                    _renderer.setSize(WIDTH, HEIGHT);
                    _camera.aspect = WIDTH / HEIGHT;
                    _camera.updateProjectionMatrix();
                });

                // Set the background color of the scene.
                _renderer.setClearColor(_backgroundColour, .1);

                // Create a light, set its position, and add it to the scene.
                _light = new THREE.PointLight(0xffffff);
                _light.position.set(-100,200,100);
                _light.castShadow = true;
                _light.shadowMapWidth = 2048;
                _light.shadowMapHeight = 2048;
                _light.shadowCameraFov = 45;
                _scene.add(_light);

                // ..and now te ambient light

                _lightAmbient   = new THREE.DirectionalLight(0xff00ff,1);
                _lightAmbient.position.set(100,-700,-300);
                _scene.add(_lightAmbient);

                // Load in the mesh and add it to the scene.
                var loader = new THREE.JSONLoader();
                loader.load( _model, function(geometry){
                    var imgTexture = THREE.ImageUtils.loadTexture( 'models/camo.png' )
                    imgTexture.repeat.set( 4, 2 );
                    imgTexture.wrapS = imgTexture.wrapT = THREE.ClampToEdgeWrapping;
                    imgTexture.anisotropy = 16;

                     geometry.computeTangents();


                   // var material = new THREE.MeshLambertMaterial({color: 0xffffff});
                    var material = new THREE.MeshPhongMaterial({color: 0xffffff, map:imgTexture});
                    mesh = new THREE.Mesh(geometry, material);
                    _scene.add(mesh);


                    // ADD A BUNCH OF MONKEYS...

                        for ( var i = 0; i < 5; i ++ ) {



                        var __material = new THREE.MeshPhongMaterial({color: _lambertArr[i]});

//                            __material.needsUpdate = true;
//                            geometry.buffersNeedUpdate = true;
//                            geometry.uvsNeedUpdate = true;
//                            __material.side = THREE.DoubleSide

                        var __mesh = new THREE.Mesh( geometry, material );

                            __mesh.position.x = i * 2;
                            __mesh.position.y = i * 2;
                            __mesh.position.z = i * 2;
                            __mesh.rotation.z = i * 10;
                            __mesh.updateMatrix();
                            __mesh.matrixAutoUpdate = true;
                        _scene.add( __mesh );
                            _monkeys.push(__mesh)
                    }

            /*
            ADD A BOG STANDARD CUBE


             */

                    var boxGeometry = new THREE.BoxGeometry(100,1,100);
                        boxGeometry.computeBoundingSphere()

                    /*
                     color — geometry color in hexadecimal. Default is 0xffffff.
                     wireframe — render geometry as wireframe. Default is false.
                     wireframeLinewidth — Line thickness. Default is 1.
                     wireframeLinecap — Define appearance of line ends. Default is 'round'.
                     wireframeLinejoin — Define appearance of line joints. Default is 'round'.
                     shading — Define shading type. Default is THREE.SmoothShading.
                     vertexColors — Define how the vertices gets colored. Default is THREE.NoColors.
                     fog — Define whether the material color is affected by global fog settings. Default is true.
                     lightMap — Set light map. Default is null.
                     specularMap — Set specular map. Default is null.
                     envMap — Set env map. Default is null.
                     skinning — Define whether the material uses skinning. Default is false.
                     morphTargets — Define whether the material uses morphTargets. Default is false.
                     */
                    var boxMaterial = new THREE.MeshBasicMaterial( { color: 0xcccccc,
                        wireframe:true,
                        shading:THREE.SmoothShading,
                    } );

                    var cube = new THREE.Mesh( boxGeometry, boxMaterial );
                    _scene.add( cube );



                    // Add OrbitControls so that we can pan around with the mouse.
                    _controls = new THREE.OrbitControls(_camera, _renderer.domElement);

                    requestAnimationFrame(animate);
                });
                ///

                // Renders the scene and updates the render as needed.
                function animate() {
                    //_monkeys[1].position.x += .002;
                    _monkeys[2].rotation.z -= _clock.getDelta();
                    _monkeys[1].rotation.z -= .03;
                    _monkeys[3].rotation.x -= .03;
                    _monkeys[3].rotation.z -= .03;

                    _vector = new THREE.Vector3( _mouse.x, _mouse.y, 1 );
                    _projector.unprojectVector( _vector, _camera );
                    _raycaster.set( _camera.position, _vector.sub( _camera.position ).normalize() );

                    var mesh = _monkeys[4]

                    var intersects = _raycaster.intersectObject( mesh );


                    if ( intersects.length > 0 ) {

                        var intersect = intersects[ 0 ];


                        var color = new THREE.Color( 1, 0, 0 );

                        console.log("intersects  ",intersects);

                        var material = new THREE.MeshPhongMaterial();
                        //material.color = color
                        material.emissive = color;
                        material.shininess = 100;
                        material.shading = THREE.SmoothShading;

                        if( intersect  ) console.log(intersect.object.material);
                        intersect.object.material = material;
                        var object = intersect.object;
                        mesh.rotation.z -= .04;

                        mesh.updateMatrix();

                       _line.geometry.applyMatrix( mesh.matrix );

                        _line.visible = true;

                    }



                    for(var mnk in _monkeys){
                        _monkeys[mnk].updateMatrix()
                    }

                    // Render the scene.
                    _renderer.render(_scene, _camera);
                    _controls.update();
                    // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                    requestAnimationFrame(animate);
                }


                document.addEventListener( 'mousemove', onDocumentMouseMove, false );

            }
            ///////////////////////////////

            /*
            Test for the mouse position
             */

            function onDocumentMouseMove( event ) {

                event.preventDefault();

                _mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                _mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }



        </script>